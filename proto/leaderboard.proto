syntax = "proto3";

option go_package = "github.com/momentohq/client-sdk-go;client_sdk_go";
option java_multiple_files = true;
option java_package = "grpc.leaderboard";
option csharp_namespace = "Momento.Protos.Leaderboard";

package leaderboard;

// Like a sorted set, but for leaderboards!
//
// Elements in a leaderboard are keyed by an ID, which is an unsigned 64 bit integer.
// Scores are single-precision floating point numbers.
//
// Each ID can have only 1 score.
//
// For batchy, multi-element apis, limits are 8192 elements per api call.
service Leaderboard {
  // Deletes a leaderboard. After this call, you're not incurring storage cost for this leaderboard anymore.
  rpc DeleteLeaderboard(_DeleteLeaderboardRequest) returns (_Empty);

  // Insert or update elements in a leaderboard. You can do up to 8192 elements per call.
  // There is no partial failure: Upsert succeeds or fails.
  rpc UpsertBigIntElements(_UpsertBigIntElementsRequest) returns (_Empty);
  rpc UpsertDoubleElements(_UpsertDoubleElementsRequest) returns (_Empty);

  // Remove up to 8192 elements at a time from a leaderboard. Elements are removed by id.
  rpc RemoveElements(_RemoveElementsRequest) returns (_Empty);

  // Returns the length of a leaderboard in terms of ID count. 
  rpc GetLeaderboardLength(_GetLeaderboardLengthRequest) returns (_GetLeaderboardLengthResponse);

  // Get a range of elements.
  // * Ordinal, 0-based rank.
  // * Range can span up to 8192 elements.
  // See RankRange for details about permissible ranges.
  rpc GetByRankBigInt(_GetByRankBigIntRequest) returns (_GetByRankBigIntResponse);
  rpc GetByRankDouble(_GetByRankDoubleRequest) returns (_GetByRankDoubleResponse);

  // Get the rank of a list of particular ids in the leaderboard.
  // * Ordinal, 0-based rank.
  rpc GetRankBigInt(_GetRankBigIntRequest) returns (_GetRankBigIntResponse);
  rpc GetRankBigDouble(_GetRankDoubleRequest) returns (_GetRankDoubleResponse);

  // Get a range of elements by a score range.
  // * Ordinal, 0-based rank.
  //
  // You can request up to 8192 elements at a time. To page through many elements that all
  // fall into a score range you can repeatedly invoke this api with the offset parameter.
  rpc GetByScoreBigInt(_GetByBigIntScoreRequest) returns (_GetByBigIntScoreResponse);
  rpc GetByScoreDouble(_GetByDoubleScoreRequest) returns (_GetByDoubleScoreResponse);
}

// Leaderboards are made up of many of these.
message _BigIntElement {
  // A player identifier, session identifier, browser identifier or whatever other kind of
  // identifier you use for this scoreboard. The full unsigned 64 bit range is allowed here,
  // between 0 and 2^63-1 inclusive.
  // An id can only appear in a leaderboard one time. You can't have 2 scores for 1 player,
  // unless that player has 2 ids!
  uint64 id = 1 [jstype = JS_STRING];

  // The value by which this element is sorted within the leaderboard.
  uint64 score = 2;
}

message _DoubleElement {
  uint64 id = 1 [jstype = JS_STRING];
  double score = 2;
}

// Query APIs returning RankedElement offer the familiar Element id and score tuple, but they
// also include the rank per the individual API's ranking semantic.
message _RankedBigIntElement {
  uint64 id = 1 [jstype = JS_STRING];
  float score = 2;
  uint64 rank = 3 [jstype = JS_STRING];
}

message _RankedDoubleElement {
  uint64 id = 1 [jstype = JS_STRING];
  double score = 2;
  uint64 rank = 3 [jstype = JS_STRING];
}

// Query APIs using RankRange expect a limit of 8192 elements. Requesting a range wider than
// that is expected to return an error.
//
// RankRange models half-open ranges: 0..4 refers to elements 0, 1, 2 and 3.
//
// Example permissible ranges:
// * 0..8192
// * 1..8193
// * 123..8315
// * 0..1
// * 1..4
// * 13..17
//
// Example error ranges:
// * 0..0
// * 4..3
// * 0..8193
message _RankRange {
  uint64 start_inclusive = 1 [jstype = JS_STRING];
  uint64 end_exclusive = 2 [jstype = JS_STRING];
}

message _Unbounded { }

// Query APIs using ScoreRange may match more than the limit of 8192 elements. These apis will
// include an offset and limit parameter pair, which can be used to page through score ranges
// matching many elements.
//
// ScoreRange models half-open ranges: 0..4 refers to scores 0, 1.1234, 2.5 and 3.999.
message _BigIntScoreRange {
  oneof min {
    _Unbounded unbounded_min = 1;
    // IEEE 754 single precision 32 bit floating point number.
    // Momento does not support NaN or Inf in leaderboards.
    float min_inclusive = 2;
  }
  oneof max {
    _Unbounded unbounded_max = 3;
    // IEEE 754 single precision 32 bit floating point number.
    // Momento does not support NaN or Inf in leaderboards.
    float max_exclusive = 4;
  }
}

message _DoubleScoreRange {
  oneof min {
    _Unbounded unbounded_min = 1;
    // Momento does not support NaN or Inf in leaderboards.
    double min_inclusive = 2;
  }
  oneof max {
    _Unbounded unbounded_max = 3;
    // Momento does not support NaN or Inf in leaderboards.
    double max_exclusive = 4;
  }
}

enum _Order {
  // Ascending order (0 is the lowest-scoring rank)
  ASCENDING = 0;
  // Descending order (0 is the highest-scoring rank)
  DESCENDING = 1;
}

message _Empty {}

message _DeleteLeaderboardRequest {
  string cache_name = 1;
  string leaderboard = 2;
}

message _GetLeaderboardLengthRequest {
  string cache_name = 1;
  string leaderboard = 2;
}

message _GetLeaderboardLengthResponse {
   uint64 count = 1 [jstype = JS_STRING];
}

message _UpsertBigIntElementsRequest {
  string cache_name = 1;
  string leaderboard = 2;
  // You can have up to 8192 elements in this list.
  repeated _BigIntElement elements = 3;
}

message _UpsertDoubleElementsRequest {
  string cache_name = 1;
  string leaderboard = 2;
  // You can have up to 8192 elements in this list.
  repeated _DoubleElement elements = 3;
}

message _GetByRankBigIntRequest {
  string cache_name = 1;
  string leaderboard = 2;
  _RankRange rank_range = 3;
  _Order order = 4;
}
message _GetByRankDoubleRequest {
  string cache_name = 1;
  string leaderboard = 2;
  _RankRange rank_range = 3;
  _Order order = 4;
}

message _GetByRankBigIntResponse {
  repeated _RankedBigIntElement elements = 1;
}
message _GetByRankDoubleResponse {
  repeated _RankedDoubleElement elements = 1;
}

message _GetRankBigIntRequest {
  string cache_name = 1;
  string leaderboard = 2;
  repeated uint64 ids = 3 [jstype = JS_STRING];
  _Order order = 4;
}
message _GetRankDoubleRequest {
  string cache_name = 1;
  string leaderboard = 2;
  repeated uint64 ids = 3 [jstype = JS_STRING];
  _Order order = 4;
}

message _GetRankBigIntResponse {
  repeated _RankedBigIntElement elements = 1;
}
message _GetRankDoubleResponse {
  repeated _RankedDoubleElement elements = 1;
}

message _RemoveElementsRequest {
  string cache_name = 1;
  string leaderboard = 2;
  // You can have up to 8192 ids in this list.
  repeated uint64 ids = 3 [jstype = JS_STRING];
}

message _GetByBigIntScoreRequest {
  string cache_name = 1;
  string leaderboard = 2;
  _BigIntScoreRange score_range = 3;
  // Where should we start returning scores from in the elements within this range?
  uint64 offset = 4 [jstype = JS_STRING];
  // How many elements should we limit to returning? (8192 max)
  uint64 limit_elements = 5 [jstype = JS_STRING];
  _Order order = 6;
}

message _GetByDoubleScoreRequest {
  string cache_name = 1;
  string leaderboard = 2;
  _DoubleScoreRange score_range = 3;
  // Where should we start returning scores from in the elements within this range?
  uint64 offset = 4 [jstype = JS_STRING];
  // How many elements should we limit to returning? (8192 max)
  uint64 limit_elements = 5 [jstype = JS_STRING];
  _Order order = 6;
}

message _GetByBigIntScoreResponse {
  repeated _RankedBigIntElement elements = 1;
}
message _GetByDoubleScoreResponse {
  repeated _RankedDoubleElement elements = 1;
}
