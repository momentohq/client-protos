// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Permissions {
    #[prost(oneof = "permissions::Kind", tags = "1, 2")]
    pub kind: ::core::option::Option<permissions::Kind>,
}
/// Nested message and enum types in `Permissions`.
pub mod permissions {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(enumeration = "super::SuperUserPermissions", tag = "1")]
        SuperUser(i32),
        #[prost(message, tag = "2")]
        Explicit(super::ExplicitPermissions),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExplicitPermissions {
    #[prost(message, repeated, tag = "1")]
    pub permissions: ::prost::alloc::vec::Vec<PermissionsType>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PermissionsType {
    #[prost(oneof = "permissions_type::Kind", tags = "1, 2, 3")]
    pub kind: ::core::option::Option<permissions_type::Kind>,
}
/// Nested message and enum types in `PermissionsType`.
pub mod permissions_type {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct All {}
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CacheSelector {
        #[prost(oneof = "cache_selector::Kind", tags = "1")]
        pub kind: ::core::option::Option<cache_selector::Kind>,
    }
    /// Nested message and enum types in `CacheSelector`.
    pub mod cache_selector {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Kind {
            #[prost(string, tag = "1")]
            CacheName(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CacheItemSelector {
        #[prost(oneof = "cache_item_selector::Kind", tags = "1, 2")]
        pub kind: ::core::option::Option<cache_item_selector::Kind>,
    }
    /// Nested message and enum types in `CacheItemSelector`.
    pub mod cache_item_selector {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Kind {
            #[prost(bytes, tag = "1")]
            Key(::prost::alloc::vec::Vec<u8>),
            #[prost(bytes, tag = "2")]
            KeyPrefix(::prost::alloc::vec::Vec<u8>),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CachePermissions {
        #[prost(enumeration = "super::CacheRole", tag = "1")]
        pub role: i32,
        #[prost(oneof = "cache_permissions::Cache", tags = "2, 3")]
        pub cache: ::core::option::Option<cache_permissions::Cache>,
        #[prost(oneof = "cache_permissions::CacheItem", tags = "4, 5")]
        pub cache_item: ::core::option::Option<cache_permissions::CacheItem>,
    }
    /// Nested message and enum types in `CachePermissions`.
    pub mod cache_permissions {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Cache {
            #[prost(message, tag = "2")]
            AllCaches(super::All),
            #[prost(message, tag = "3")]
            CacheSelector(super::CacheSelector),
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum CacheItem {
            #[prost(message, tag = "4")]
            AllItems(super::All),
            #[prost(message, tag = "5")]
            ItemSelector(super::CacheItemSelector),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TopicSelector {
        #[prost(oneof = "topic_selector::Kind", tags = "1, 2")]
        pub kind: ::core::option::Option<topic_selector::Kind>,
    }
    /// Nested message and enum types in `TopicSelector`.
    pub mod topic_selector {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Kind {
            #[prost(string, tag = "1")]
            TopicName(::prost::alloc::string::String),
            #[prost(string, tag = "2")]
            TopicNamePrefix(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TopicPermissions {
        #[prost(enumeration = "super::TopicRole", tag = "1")]
        pub role: i32,
        #[prost(oneof = "topic_permissions::Cache", tags = "2, 3")]
        pub cache: ::core::option::Option<topic_permissions::Cache>,
        #[prost(oneof = "topic_permissions::Topic", tags = "4, 5")]
        pub topic: ::core::option::Option<topic_permissions::Topic>,
    }
    /// Nested message and enum types in `TopicPermissions`.
    pub mod topic_permissions {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Cache {
            #[prost(message, tag = "2")]
            AllCaches(super::All),
            #[prost(message, tag = "3")]
            CacheSelector(super::CacheSelector),
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Topic {
            #[prost(message, tag = "4")]
            AllTopics(super::All),
            #[prost(message, tag = "5")]
            TopicSelector(super::TopicSelector),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FunctionSelector {
        #[prost(oneof = "function_selector::Kind", tags = "1, 2")]
        pub kind: ::core::option::Option<function_selector::Kind>,
    }
    /// Nested message and enum types in `FunctionSelector`.
    pub mod function_selector {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Kind {
            #[prost(string, tag = "1")]
            FunctionName(::prost::alloc::string::String),
            #[prost(string, tag = "2")]
            FunctionNamePrefix(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FunctionPermissions {
        #[prost(enumeration = "super::FunctionRole", tag = "1")]
        pub role: i32,
        #[prost(oneof = "function_permissions::Cache", tags = "2, 3")]
        pub cache: ::core::option::Option<function_permissions::Cache>,
        #[prost(oneof = "function_permissions::Function", tags = "4, 5")]
        pub function: ::core::option::Option<function_permissions::Function>,
    }
    /// Nested message and enum types in `FunctionPermissions`.
    pub mod function_permissions {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Cache {
            #[prost(message, tag = "2")]
            AllCaches(super::All),
            #[prost(message, tag = "3")]
            CacheSelector(super::CacheSelector),
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Function {
            #[prost(message, tag = "4")]
            AllFunctions(super::All),
            #[prost(message, tag = "5")]
            FunctionSelector(super::FunctionSelector),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        CachePermissions(CachePermissions),
        #[prost(message, tag = "2")]
        TopicPermissions(TopicPermissions),
        #[prost(message, tag = "3")]
        FunctionPermissions(FunctionPermissions),
    }
}
/// Aliases for categories of functionality.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CacheRole {
    CachePermitNone = 0,
    /// Restricts access to apis that read and write data from caches: No higher level resource description or modification.
    CacheReadWrite = 1,
    /// Restricts access to apis that read from caches: No higher level resource description or modification.
    CacheReadOnly = 2,
    /// Restricts access to apis that write from caches: No higher level resource description or modification.
    /// Doesn't allow conditional write APIs (SetIfNotExists, IncreaseTTL etc)
    CacheWriteOnly = 3,
}
impl CacheRole {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CachePermitNone => "CachePermitNone",
            Self::CacheReadWrite => "CacheReadWrite",
            Self::CacheReadOnly => "CacheReadOnly",
            Self::CacheWriteOnly => "CacheWriteOnly",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CachePermitNone" => Some(Self::CachePermitNone),
            "CacheReadWrite" => Some(Self::CacheReadWrite),
            "CacheReadOnly" => Some(Self::CacheReadOnly),
            "CacheWriteOnly" => Some(Self::CacheWriteOnly),
            _ => None,
        }
    }
}
/// Aliases for categories of functionality.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TopicRole {
    TopicPermitNone = 0,
    /// Restricts access to apis that read and write data from topics: No higher level resource description or modification.
    TopicReadWrite = 1,
    /// Restricts access to apis that read from topics: No higher level resource description or modification.
    TopicReadOnly = 2,
    /// Restricts access to apis that write from topics: No higher level resource description or modification.
    TopicWriteOnly = 3,
}
impl TopicRole {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TopicPermitNone => "TopicPermitNone",
            Self::TopicReadWrite => "TopicReadWrite",
            Self::TopicReadOnly => "TopicReadOnly",
            Self::TopicWriteOnly => "TopicWriteOnly",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TopicPermitNone" => Some(Self::TopicPermitNone),
            "TopicReadWrite" => Some(Self::TopicReadWrite),
            "TopicReadOnly" => Some(Self::TopicReadOnly),
            "TopicWriteOnly" => Some(Self::TopicWriteOnly),
            _ => None,
        }
    }
}
/// Aliases for categories of functionality.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FunctionRole {
    FunctionPermitNone = 0,
    FunctionInvoke = 1,
}
impl FunctionRole {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::FunctionPermitNone => "FunctionPermitNone",
            Self::FunctionInvoke => "FunctionInvoke",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FunctionPermitNone" => Some(Self::FunctionPermitNone),
            "FunctionInvoke" => Some(Self::FunctionInvoke),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SuperUserPermissions {
    SuperUser = 0,
}
impl SuperUserPermissions {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SuperUser => "SuperUser",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SuperUser" => Some(Self::SuperUser),
            _ => None,
        }
    }
}
